<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ - Ù…Ø­Ø§Ø³Ø¨ Ø£Ø­Ù…Ø¯ Ù…Ø¨Ø±ÙˆÙƒ</title>
    <link href="https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&family=Cairo:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Cairo', 'Amiri', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            margin-bottom: 40px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 40px;
        }
        
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-bottom: 20px;
        }
        
        .game-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 15px;
        }
        
        .game-card:hover {
            transform: translateY(-10px);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }
        
        .game-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            display: block;
        }
        
        .game-title {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .game-description {
            font-size: 1rem;
            opacity: 0.8;
            margin-bottom: 25px;
            line-height: 1.6;
        }
        
        .play-button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            margin-bottom: 30px;
        }
        
        .play-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 25px rgba(255, 107, 107, 0.4);
        }
        
        .game-interface {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .game-interface.active {
            display: block;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .back-button, .tutorial-button {
            background: #6c5ce7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .back-button:hover, .tutorial-button:hover {
            background: #5f3dc4;
            transform: scale(1.05);
        }
        
        .game-board {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #e9ecef;
        }
        
        .game-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .control-button {
            background: #00b894;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .control-button:hover {
            background: #00a085;
            transform: scale(1.05);
        }
        
        .control-button:disabled {
            background: #ddd;
            cursor: not-allowed;
            transform: none;
        }
        
        .game-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            background: #2d3436;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }
        
        .stat-item {
            text-align: center;
            color: white;
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #00b894;
        }
        
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            gap: 1px;
            background: #8B4513;
            padding: 10px;
            border-radius: 10px;
            margin: 0 auto;
        }
        
        .chess-square {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .chess-square.light {
            background: #f0d9b5;
        }
        
        .chess-square.dark {
            background: #b58863;
        }
        
        .chess-square:hover {
            background: #7fb069 !important;
        }
        
        .chess-square.selected {
            background: #7fb069 !important;
            box-shadow: inset 0 0 0 3px #2d5016;
        }
        
        .backgammon-board {
            background: #8B4513;
            border-radius: 15px;
            padding: 20px;
            margin: 0 auto;
            max-width: 600px;
        }
        
        .domino-board {
            background: #2d5016;
            border-radius: 15px;
            padding: 20px;
            margin: 0 auto;
            min-height: 300px;
        }
        
        .space-game-canvas, .racing-game-canvas {
            background: linear-gradient(180deg, #000428 0%, #004e92 100%);
            border-radius: 15px;
            margin: 0 auto;
            display: block;
        }
        
        .racing-game-canvas {
            background: linear-gradient(180deg, #87CEEB 0%, #228B22 100%);
        }
        
        .tips {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            color: #333;
        }
        
        .tips h4 {
            color: #f39c12;
            margin-bottom: 10px;
        }
        
        .footer {
            text-align: center;
            padding: 40px 20px;
            background: rgba(0,0,0,0.2);
            margin-top: 50px;
        }
        
        .footer p {
            margin-bottom: 10px;
            opacity: 0.8;
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .games-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .game-header {
                flex-direction: column;
                gap: 10px;
            }
            
            .chess-board {
                grid-template-columns: repeat(8, 35px);
                grid-template-rows: repeat(8, 35px);
            }
            
            .chess-square {
                width: 35px;
                height: 35px;
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ® Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ ğŸ¯</h1>
            <p>Ø£Ù„Ø¹Ø§Ø¨ Ø°ÙƒÙŠØ© ÙˆÙ…Ù…ØªØ¹Ø© Ù„Ù„ÙƒØ¨Ø§Ø± ÙˆØ§Ù„ØµØºØ§Ø± - Ù…Ø¹ Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù„Ø±ÙŠÙ…ÙˆØª ÙƒÙ†ØªØ±ÙˆÙ„</p>
        </div>
        
        <!-- Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© -->
        <div id="main-menu" class="games-grid">
            <div class="game-card">
                <span class="game-icon">â™”</span>
                <div class="game-title">Ø§Ù„Ø´Ø·Ø±Ù†Ø¬</div>
                <div class="game-description">Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ù„ÙˆÙƒ ÙˆØ§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ù…Ø¹ Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªÙ‚Ø¯Ù… ÙˆØ¯Ø±ÙˆØ³ ØªØ¹Ù„ÙŠÙ…ÙŠØ© Ø´Ø§Ù…Ù„Ø©</div>
                <button class="play-button" onclick="showGame('chess')">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
            </div>
            
            <div class="game-card">
                <span class="game-icon">ğŸ²</span>
                <div class="game-title">Ø§Ù„Ø·Ø§ÙˆÙ„Ø©</div>
                <div class="game-description">Ù„Ø¹Ø¨Ø© Ø§Ù„Ø­Ø¸ ÙˆØ§Ù„Ù…Ù‡Ø§Ø±Ø© Ø§Ù„ØªØ±Ø§Ø«ÙŠØ© Ø§Ø³ØªÙ…ØªØ¹ Ù…Ø¹ 8 Ø£Ù†ÙˆØ§Ø¹ Ù…Ø®ØªÙ„ÙØ© Ù…Ù† Ø§Ù„Ø·Ø§ÙˆÙ„Ø©</div>
                <button class="play-button" onclick="showGame('backgammon')">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
            </div>
            
            <div class="game-card">
                <span class="game-icon">ğŸ€«</span>
                <div class="game-title">Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ</div>
                <div class="game-description">Ù„Ø¹Ø¨Ø© Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„ØªØ®Ø·ÙŠØ· Ù…Ø¹ 28 Ù‚Ø·Ø¹Ø© ÙƒØ§Ù…Ù„Ø© ÙˆØ°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªØ·ÙˆØ±</div>
                <button class="play-button" onclick="showGame('domino')">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
            </div>
            
            <div class="game-card">
                <span class="game-icon">ğŸš€</span>
                <div class="game-title">Ø­Ø±Ø¨ Ø§Ù„Ù†Ø¬ÙˆÙ…</div>
                <div class="game-description">Ù…ØºØ§Ù…Ø±Ø© ÙØ¶Ø§Ø¦ÙŠØ© Ù…Ø«ÙŠØ±Ø© Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø£Ø·ÙØ§Ù„ Ù…Ù† 3 Ø³Ù†ÙˆØ§Øª Ù…Ø¹ Ø±Ø³ÙˆÙ…ÙŠØ§Øª Ø¬Ù…ÙŠÙ„Ø©</div>
                <button class="play-button" onclick="showGame('space')">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù…ØºØ§Ù…Ø±Ø©</button>
            </div>
            
            <div class="game-card">
                <span class="game-icon">ğŸï¸</span>
                <div class="game-title">Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ø±Ø§Øª</div>
                <div class="game-description">Ø³Ø¨Ø§Ù‚ Ø³Ø±ÙŠØ¹ ÙˆÙ…Ø«ÙŠØ± ØªØ¬Ù†Ø¨ Ø§Ù„Ø³ÙŠØ§Ø±Ø§Øª ÙˆØ§Ø¬Ù…Ø¹ Ø£ÙƒØ¨Ø± Ø¹Ø¯Ø¯ Ù…Ù† Ø§Ù„Ù†Ù‚Ø§Ø·</div>
                <button class="play-button" onclick="showGame('racing')">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø³Ø¨Ø§Ù‚</button>
            </div>
        </div>
        
        <!-- ÙˆØ§Ø¬Ù‡Ø© Ù„Ø¹Ø¨Ø© Ø§Ù„Ø´Ø·Ø±Ù†Ø¬ -->
        <div id="chess-game" class="game-interface">
            <div class="game-header">
                <button class="back-button" onclick="showMainMenu()">Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
                <h2>â™” Ø§Ù„Ø´Ø·Ø±Ù†Ø¬</h2>
                <button class="tutorial-button" onclick="showTutorial('chess')">ğŸ“š Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ</button>
            </div>
            
            <div class="game-stats">
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ù„Ø§Ø¹Ø¨</div>
                    <div class="stat-value" id="chess-player-score">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±</div>
                    <div class="stat-value" id="chess-ai-score">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ù…Ø³ØªÙˆÙ‰</div>
                    <div class="stat-value" id="chess-level">Ù…ØªÙˆØ³Ø·</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ø¯ÙˆØ±</div>
                    <div class="stat-value" id="chess-turn">Ø§Ù„Ø£Ø¨ÙŠØ¶</div>
                </div>
            </div>
            
            <div class="game-board">
                <div id="chess-board" class="chess-board"></div>
            </div>
            
            <div class="game-controls">
                <button class="control-button" onclick="newChessGame()">Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
                <button class="control-button" onclick="undoChessMove()" id="undo-btn">ØªØ±Ø§Ø¬Ø¹</button>
                <button class="control-button" onclick="getChessHint()" id="hint-btn">Ù†ØµÙŠØ­Ø©</button>
                <select id="chess-difficulty" onchange="setChessDifficulty()" class="control-button">
                    <option value="easy">Ø³Ù‡Ù„</option>
                    <option value="medium" selected>Ù…ØªÙˆØ³Ø·</option>
                    <option value="hard">ØµØ¹Ø¨</option>
                    <option value="expert">Ø®Ø¨ÙŠØ±</option>
                </select>
            </div>
            
            <div class="tips">
                <h4>ğŸ’¡ Ù†ØµØ§Ø¦Ø­ ÙˆØ§Ù‚ØªØ±Ø§Ø­Ø§Øª:</h4>
                <p id="chess-tips">Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø³Ù‡Ù… Ù„Ù„ØªÙ†Ù‚Ù„ ÙˆØ§Ù„Ù…Ø³Ø§ÙØ© Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±. Ø§Ø¨Ø¯Ø£ Ø¨ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¨ÙŠØ§Ø¯Ù‚ ÙÙŠ Ø§Ù„Ù…Ù†ØªØµÙ Ù„ØªØ·ÙˆÙŠØ± Ù‚Ø·Ø¹Ùƒ Ø¨Ø³Ø±Ø¹Ø©.</p>
            </div>
        </div>
        
        <!-- ÙˆØ§Ø¬Ù‡Ø© Ù„Ø¹Ø¨Ø© Ø§Ù„Ø·Ø§ÙˆÙ„Ø© -->
        <div id="backgammon-game" class="game-interface">
            <div class="game-header">
                <button class="back-button" onclick="showMainMenu()">Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
                <h2>ğŸ² Ø§Ù„Ø·Ø§ÙˆÙ„Ø©</h2>
                <button class="tutorial-button" onclick="showTutorial('backgammon')">ğŸ“š Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ</button>
            </div>
            
            <div class="game-controls">
                <label for="backgammon-type">Ù†ÙˆØ¹ Ø§Ù„Ø·Ø§ÙˆÙ„Ø©:</label>
                <select id="backgammon-type" onchange="changeBackgammonType()" class="control-button">
                    <option value="classic">Ø§Ù„Ø·Ø§ÙˆÙ„Ø© Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©</option>
                    <option value="mahbusa">Ø§Ù„Ø·Ø§ÙˆÙ„Ø© Ø§Ù„Ù…Ø­Ø¨ÙˆØ³Ø©</option>
                    <option value="plakoto">Ø§Ù„Ø¨Ù„Ø§ÙƒÙˆØªÙˆ</option>
                    <option value="fevga">Ø§Ù„ÙÙŠÚ¤Ø¬Ø§</option>
                    <option value="gul_bara">Ø¬ÙˆÙ„ Ø¨Ø§Ø±Ø§</option>
                    <option value="tapa">Ø§Ù„ØªØ§Ø¨Ø§</option>
                    <option value="sugoroku">Ø§Ù„Ø³ÙˆØ¬ÙˆØ±ÙˆÙƒÙˆ</option>
                    <option value="nackgammon">Ø§Ù„Ù†Ø§ÙƒØ¬Ø§Ù…ÙˆÙ†</option>
                </select>
            </div>
            
            <div class="game-stats">
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ù„Ø§Ø¹Ø¨</div>
                    <div class="stat-value" id="backgammon-player-score">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±</div>
                    <div class="stat-value" id="backgammon-ai-score">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ù†Ø±Ø¯</div>
                    <div class="stat-value" id="backgammon-dice">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ø¯ÙˆØ±</div>
                    <div class="stat-value" id="backgammon-turn">Ø§Ù„Ù„Ø§Ø¹Ø¨</div>
                </div>
            </div>
            
            <div class="game-board">
                <div id="backgammon-board" class="backgammon-board">
                    <p>Ù„ÙˆØ­Ø© Ø§Ù„Ø·Ø§ÙˆÙ„Ø© - Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯" Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨</p>
                </div>
            </div>
            
            <div class="game-controls">
                <button class="control-button" onclick="rollBackgammonDice()" id="roll-dice-btn">Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯</button>
                <button class="control-button" onclick="newBackgammonGame()">Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
                <button class="control-button" onclick="getBackgammonHint()">Ù†ØµÙŠØ­Ø©</button>
            </div>
            
            <div class="tips">
                <h4>ğŸ’¡ Ù†ØµØ§Ø¦Ø­ ÙˆØ§Ù‚ØªØ±Ø§Ø­Ø§Øª:</h4>
                <p id="backgammon-tips">Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø³Ù‡Ù… Ù„Ù„ØªÙ†Ù‚Ù„ Ø¨ÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„Ù…Ø³Ø§ÙØ© Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø­Ø¬Ø§Ø±Ø©. Ø­Ø§ÙˆÙ„ Ø¨Ù†Ø§Ø¡ Ù†Ù‚Ø§Ø· Ù‚ÙˆÙŠØ© Ù„Ù…Ù†Ø¹ Ø®ØµÙ…Ùƒ Ù…Ù† Ø§Ù„ØªÙ‚Ø¯Ù….</p>
            </div>
        </div>
        
        <!-- ÙˆØ§Ø¬Ù‡Ø© Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ -->
        <div id="domino-game" class="game-interface">
            <div class="game-header">
                <button class="back-button" onclick="showMainMenu()">Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
                <h2>ğŸ€« Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ</h2>
                <button class="tutorial-button" onclick="showTutorial('domino')">ğŸ“š Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ</button>
            </div>
            
            <div class="game-stats">
                <div class="stat-item">
                    <div class="stat-label">Ù†Ù‚Ø§Ø·Ùƒ</div>
                    <div class="stat-value" id="domino-player-score">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±</div>
                    <div class="stat-value" id="domino-ai-score">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ù‚Ø·Ø¹Ùƒ</div>
                    <div class="stat-value" id="domino-player-pieces">7</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ø¯ÙˆØ±</div>
                    <div class="stat-value" id="domino-turn">Ø§Ù„Ù„Ø§Ø¹Ø¨</div>
                </div>
            </div>
            
            <div class="game-board">
                <div id="domino-board" class="domino-board">
                    <p>Ù„ÙˆØ­Ø© Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ - Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©" Ù„Ù„Ø¨Ø¯Ø¡</p>
                </div>
            </div>
            
            <div class="game-controls">
                <button class="control-button" onclick="newDominoGame()">Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
                <button class="control-button" onclick="passDominoTurn()" id="pass-turn-btn">ØªÙ…Ø±ÙŠØ± Ø§Ù„Ø¯ÙˆØ±</button>
                <button class="control-button" onclick="getDominoHint()">Ù†ØµÙŠØ­Ø©</button>
            </div>
            
            <div class="tips">
                <h4>ğŸ’¡ Ù†ØµØ§Ø¦Ø­ ÙˆØ§Ù‚ØªØ±Ø§Ø­Ø§Øª:</h4>
                <p id="domino-tips">Ø§Ø®ØªØ± Ù‚Ø·Ø¹Ø© Ù…Ù† ÙŠØ¯Ùƒ ÙˆØ§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙƒØ§Ù† Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø©. Ø­Ø§ÙˆÙ„ Ø§Ù„ØªØ®Ù„Øµ Ù…Ù† Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø«Ù‚ÙŠÙ„Ø© Ø£ÙˆÙ„Ø§Ù‹.</p>
            </div>
        </div>
        
        <!-- ÙˆØ§Ø¬Ù‡Ø© Ù„Ø¹Ø¨Ø© Ø­Ø±Ø¨ Ø§Ù„Ù†Ø¬ÙˆÙ… -->
        <div id="space-game" class="game-interface">
            <div class="game-header">
                <button class="back-button" onclick="showMainMenu()">Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
                <h2>ğŸš€ Ø­Ø±Ø¨ Ø§Ù„Ù†Ø¬ÙˆÙ…</h2>
                <button class="tutorial-button" onclick="showTutorial('space')">ğŸ“š Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ</button>
            </div>
            
            <div class="game-controls">
                <label for="space-difficulty">Ø§Ù„Ù…Ø³ØªÙˆÙ‰:</label>
                <select id="space-difficulty" onchange="setSpaceDifficulty()" class="control-button">
                    <option value="easy">Ø³Ù‡Ù„</option>
                    <option value="medium" selected>Ù…ØªÙˆØ³Ø·</option>
                    <option value="hard">ØµØ¹Ø¨</option>
                    <option value="expert">Ø®Ø¨ÙŠØ±</option>
                </select>
            </div>
            
            <div class="game-board">
                <canvas id="space-canvas" class="space-game-canvas" width="800" height="400"></canvas>
            </div>
            
            <div class="game-stats">
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡</div>
                    <div class="stat-value" id="space-enemies">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ù…Ø³ØªÙˆÙ‰</div>
                    <div class="stat-value" id="space-level">1</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ø£Ø±ÙˆØ§Ø­</div>
                    <div class="stat-value" id="space-lives">3</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ù†Ù‚Ø§Ø·</div>
                    <div class="stat-value" id="space-score">0</div>
                </div>
            </div>
            
            <div class="game-controls">
                <button class="control-button" onclick="startSpaceGame()">Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
                <button class="control-button" onclick="pauseSpaceGame()" id="pause-space-btn">Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª</button>
                <button class="control-button" onclick="newSpaceGame()">Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
            </div>
            
            <div class="tips">
                <h4>ğŸ’¡ Ù†ØµØ§Ø¦Ø­ ÙˆØ§Ù‚ØªØ±Ø§Ø­Ø§Øª:</h4>
                <p id="space-tips">Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø³Ù‡Ù… Ù„Ù„Ø­Ø±ÙƒØ© ÙˆØ§Ù„Ù…Ø³Ø§ÙØ© Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±. ØªØ¬Ù†Ø¨ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ ÙˆØ§Ø¬Ù…Ø¹ Ø§Ù„Ù†Ù‚Ø§Ø·.</p>
            </div>
        </div>
        
        <!-- ÙˆØ§Ø¬Ù‡Ø© Ù„Ø¹Ø¨Ø© Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ø±Ø§Øª -->
        <div id="racing-game" class="game-interface">
            <div class="game-header">
                <button class="back-button" onclick="showMainMenu()">Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
                <h2>ğŸï¸ Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ø±Ø§Øª</h2>
                <button class="tutorial-button" onclick="showTutorial('racing')">ğŸ“š Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ</button>
            </div>
            
            <div class="game-controls">
                <label for="racing-difficulty">Ø§Ù„Ù…Ø³ØªÙˆÙ‰:</label>
                <select id="racing-difficulty" onchange="setRacingDifficulty()" class="control-button">
                    <option value="easy">Ø³Ù‡Ù„</option>
                    <option value="medium" selected>Ù…ØªÙˆØ³Ø·</option>
                    <option value="hard">ØµØ¹Ø¨</option>
                    <option value="expert">Ø®Ø¨ÙŠØ±</option>
                </select>
            </div>
            
            <div class="game-board">
                <canvas id="racing-canvas" class="racing-game-canvas" width="800" height="400"></canvas>
            </div>
            
            <div class="game-stats">
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„ÙˆÙ‚Øª</div>
                    <div class="stat-value" id="racing-time">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ù…Ø³Ø§ÙØ©</div>
                    <div class="stat-value" id="racing-distance">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ø³Ø±Ø¹Ø©</div>
                    <div class="stat-value" id="racing-speed">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ù†Ù‚Ø§Ø·</div>
                    <div class="stat-value" id="racing-score">0</div>
                </div>
            </div>
            
            <div class="game-controls">
                <button class="control-button" onclick="startRacingGame()">Ø¨Ø¯Ø¡ Ø§Ù„Ø³Ø¨Ø§Ù‚</button>
                <button class="control-button" onclick="pauseRacingGame()" id="pause-racing-btn">Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª</button>
                <button class="control-button" onclick="newRacingGame()">Ø³Ø¨Ø§Ù‚ Ø¬Ø¯ÙŠØ¯</button>
            </div>
            
            <div class="tips">
                <h4>ğŸ’¡ Ù†ØµØ§Ø¦Ø­ ÙˆØ§Ù‚ØªØ±Ø§Ø­Ø§Øª:</h4>
                <p id="racing-tips">Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø³Ù‡Ù… ÙŠØ³Ø§Ø±Ø§Ù‹ ÙˆÙŠÙ…ÙŠÙ†Ø§Ù‹ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø³ÙŠØ§Ø±Ø§Øª ÙˆØªØ¬Ø¨ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ù„Ø£ÙƒØ¨Ø± Ù…Ø³Ø§ÙØ© Ù…Ù…ÙƒÙ†Ø©.</p>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>Â© 2025 - Ø¨Ø±Ù…Ø¬Ø© ÙˆØªØ·ÙˆÙŠØ± Ù…Ø­Ø§Ø³Ø¨ Ø£Ø­Ù…Ø¯ Ù…Ø¨Ø±ÙˆÙƒ</p>
        <p>Ù…ÙˆÙ‚Ø¹ Ø£Ù„Ø¹Ø§Ø¨ ØªØ¹Ù„ÙŠÙ…ÙŠ Ø§Ø­ØªØ±Ø§ÙÙŠ - Ù…Ø¹ Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù„ØªÙ„ÙØ²ÙŠÙˆÙ† Ø§Ù„Ø°ÙƒÙŠ ÙˆØ§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</p>
    </div>

    <script>
        // Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø§Ù…Ø©
        let currentGame = 'menu';
        let gameAI = null;
        let gameState = {};
        
        // Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ù…ÙˆØ­Ø¯
        class GameAI {
            constructor(gameType, difficulty = 'medium') {
                this.gameType = gameType;
                this.difficulty = difficulty;
                this.thinkingTime = this.getThinkingTime();
            }
            
            getThinkingTime() {
                const times = {
                    'easy': 500,
                    'medium': 1000,
                    'hard': 1500,
                    'expert': 2000
                };
                return times[this.difficulty] || 1000;
            }
            
            async makeMove(gameState) {
                // Ù…Ø­Ø§ÙƒØ§Ø© ÙˆÙ‚Øª Ø§Ù„ØªÙÙƒÙŠØ±
                await new Promise(resolve => setTimeout(resolve, this.thinkingTime));
                
                switch(this.gameType) {
                    case 'chess':
                        return this.makeChessMove(gameState);
                    case 'backgammon':
                        return this.makeBackgammonMove(gameState);
                    case 'domino':
                        return this.makeDominoMove(gameState);
                    default:
                        return null;
                }
            }
            
            makeChessMove(state) {
                // Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø´Ø·Ø±Ù†Ø¬ Ø§Ù„Ù…Ø¨Ø³Ø·Ø©
                const possibleMoves = this.getChessPossibleMoves(state);
                if (possibleMoves.length === 0) return null;
                
                // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰
                switch(this.difficulty) {
                    case 'easy':
                        return possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    case 'medium':
                        return this.getBestChessMove(possibleMoves, 2);
                    case 'hard':
                        return this.getBestChessMove(possibleMoves, 3);
                    case 'expert':
                        return this.getBestChessMove(possibleMoves, 4);
                    default:
                        return possibleMoves[0];
                }
            }
            
            makeBackgammonMove(state) {
                // Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø·Ø§ÙˆÙ„Ø©
                const possibleMoves = this.getBackgammonPossibleMoves(state);
                if (possibleMoves.length === 0) return null;
                
                // Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø¨Ø³ÙŠØ·Ø©: ØªÙØ¶ÙŠÙ„ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ø¢Ù…Ù†Ø©
                const safeMoves = possibleMoves.filter(move => this.isBackgammonMoveSafe(move, state));
                const movesToUse = safeMoves.length > 0 ? safeMoves : possibleMoves;
                
                return movesToUse[Math.floor(Math.random() * movesToUse.length)];
            }
            
            makeDominoMove(state) {
                // Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ
                const possibleMoves = this.getDominoPossibleMoves(state);
                if (possibleMoves.length === 0) return null;
                
                // Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©: Ù„Ø¹Ø¨ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø«Ù‚ÙŠÙ„Ø© Ø£ÙˆÙ„Ø§Ù‹
                possibleMoves.sort((a, b) => this.getDominoPieceValue(b) - this.getDominoPieceValue(a));
                
                return possibleMoves[0];
            }
            
            // Ù…Ø³Ø§Ø¹Ø¯Ø§Øª Ø§Ù„Ø´Ø·Ø±Ù†Ø¬
            getChessPossibleMoves(state) {
                // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¨Ø³Ø· Ù„Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø©
                const moves = [];
                const board = state.board || this.getInitialChessBoard();
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color === 'black') {
                            const pieceMoves = this.getPieceValidMoves(piece, row, col, board);
                            moves.push(...pieceMoves);
                        }
                    }
                }
                
                return moves;
            }
            
            getBestChessMove(moves, depth) {
                // ØªÙ‚ÙŠÙŠÙ… Ù…Ø¨Ø³Ø· Ù„Ù„Ø­Ø±ÙƒØ§Øª
                let bestMove = moves[0];
                let bestScore = -Infinity;
                
                for (const move of moves) {
                    const score = this.evaluateChessMove(move);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                
                return bestMove;
            }
            
            evaluateChessMove(move) {
                // ØªÙ‚ÙŠÙŠÙ… Ø¨Ø³ÙŠØ· Ù„Ù„Ø­Ø±ÙƒØ©
                let score = Math.random() * 10; // Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ø£Ø³Ø§Ø³ÙŠØ©
                
                // Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø§Ø· Ù„Ù„Ø£ÙƒÙ„
                if (move.capture) {
                    const pieceValues = {
                        'pawn': 1, 'knight': 3, 'bishop': 3,
                        'rook': 5, 'queen': 9, 'king': 100
                    };
                    score += pieceValues[move.capturedPiece] || 0;
                }
                
                // Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø§Ø· Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ù…Ø±ÙƒØ²
                if (move.to.row >= 3 && move.to.row <= 4 && move.to.col >= 3 && move.to.col <= 4) {
                    score += 2;
                }
                
                return score;
            }
            
            getPieceValidMoves(piece, row, col, board) {
                // Ø­Ø±ÙƒØ§Øª Ù…Ø¨Ø³Ø·Ø© Ù„ÙƒÙ„ Ù‚Ø·Ø¹Ø©
                const moves = [];
                
                switch(piece.type) {
                    case 'pawn':
                        // Ø§Ù„Ø¨ÙŠØ¯Ù‚ ÙŠØªØ­Ø±Ùƒ Ù„Ù„Ø£Ù…Ø§Ù…
                        if (row > 0 && !board[row-1][col]) {
                            moves.push({from: {row, col}, to: {row: row-1, col}});
                        }
                        // Ø£ÙƒÙ„ Ù‚Ø·Ø±ÙŠ
                        if (row > 0 && col > 0 && board[row-1][col-1] && board[row-1][col-1].color === 'white') {
                            moves.push({from: {row, col}, to: {row: row-1, col: col-1}, capture: true});
                        }
                        if (row > 0 && col < 7 && board[row-1][col+1] && board[row-1][col+1].color === 'white') {
                            moves.push({from: {row, col}, to: {row: row-1, col: col+1}, capture: true});
                        }
                        break;
                        
                    case 'rook':
                        // Ø§Ù„Ù‚Ù„Ø¹Ø© ØªØªØ­Ø±Ùƒ Ø£ÙÙ‚ÙŠØ§Ù‹ ÙˆØ¹Ù…ÙˆØ¯ÙŠØ§Ù‹
                        for (let i = 1; i < 8; i++) {
                            if (row + i < 8) {
                                if (!board[row + i][col]) {
                                    moves.push({from: {row, col}, to: {row: row + i, col}});
                                } else {
                                    if (board[row + i][col].color === 'white') {
                                        moves.push({from: {row, col}, to: {row: row + i, col}, capture: true});
                                    }
                                    break;
                                }
                            }
                        }
                        break;
                        
                    // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù‚Ø·Ø¹ Ù‡Ù†Ø§
                }
                
                return moves;
            }
            
            // Ù…Ø³Ø§Ø¹Ø¯Ø§Øª Ø§Ù„Ø·Ø§ÙˆÙ„Ø©
            getBackgammonPossibleMoves(state) {
                // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¨Ø³Ø· Ù„Ù„Ø·Ø§ÙˆÙ„Ø©
                const moves = [];
                const dice = state.dice || [1, 1];
                
                // Ø¥Ø¶Ø§ÙØ© Ø­Ø±ÙƒØ§Øª Ù…Ù…ÙƒÙ†Ø© Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø±Ø¯
                for (let i = 0; i < 24; i++) {
                    if (state.board && state.board[i] && state.board[i].color === 'black') {
                        for (const die of dice) {
                            if (i - die >= 0) {
                                moves.push({from: i, to: i - die, die});
                            }
                        }
                    }
                }
                
                return moves;
            }
            
            isBackgammonMoveSafe(move, state) {
                // ÙØ­Øµ Ø¨Ø³ÙŠØ· Ù„Ù„Ø£Ù…Ø§Ù†
                const targetPoint = move.to;
                return !state.board || !state.board[targetPoint] || state.board[targetPoint].color !== 'white' || state.board[targetPoint].count <= 1;
            }
            
            // Ù…Ø³Ø§Ø¹Ø¯Ø§Øª Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ
            getDominoPossibleMoves(state) {
                const moves = [];
                const hand = state.aiHand || [];
                const board = state.board || [];
                
                if (board.length === 0) {
                    // Ø£ÙˆÙ„ Ø­Ø±ÙƒØ© - ÙŠÙ…ÙƒÙ† Ù„Ø¹Ø¨ Ø£ÙŠ Ù‚Ø·Ø¹Ø©
                    return hand.map((piece, index) => ({piece, index, position: 'start'}));
                }
                
                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„ØªÙŠ ÙŠÙ…ÙƒÙ† Ù„Ø¹Ø¨Ù‡Ø§
                const leftEnd = board[0];
                const rightEnd = board[board.length - 1];
                
                for (let i = 0; i < hand.length; i++) {
                    const piece = hand[i];
                    if (piece[0] === leftEnd[0] || piece[1] === leftEnd[0]) {
                        moves.push({piece, index: i, position: 'left'});
                    }
                    if (piece[0] === rightEnd[1] || piece[1] === rightEnd[1]) {
                        moves.push({piece, index: i, position: 'right'});
                    }
                }
                
                return moves;
            }
            
            getDominoPieceValue(piece) {
                return piece[0] + piece[1];
            }
            
            getInitialChessBoard() {
                // Ù„ÙˆØ­Ø© Ø´Ø·Ø±Ù†Ø¬ Ø£ÙˆÙ„ÙŠØ© Ù…Ø¨Ø³Ø·Ø©
                const board = Array(8).fill().map(() => Array(8).fill(null));
                
                // ÙˆØ¶Ø¹ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø³ÙˆØ¯Ø§Ø¡
                board[0] = [
                    {type: 'rook', color: 'black'}, {type: 'knight', color: 'black'}, 
                    {type: 'bishop', color: 'black'}, {type: 'queen', color: 'black'},
                    {type: 'king', color: 'black'}, {type: 'bishop', color: 'black'}, 
                    {type: 'knight', color: 'black'}, {type: 'rook', color: 'black'}
                ];
                
                for (let i = 0; i < 8; i++) {
                    board[1][i] = {type: 'pawn', color: 'black'};
                    board[6][i] = {type: 'pawn', color: 'white'};
                }
                
                // ÙˆØ¶Ø¹ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø¨ÙŠØ¶Ø§Ø¡
                board[7] = [
                    {type: 'rook', color: 'white'}, {type: 'knight', color: 'white'}, 
                    {type: 'bishop', color: 'white'}, {type: 'queen', color: 'white'},
                    {type: 'king', color: 'white'}, {type: 'bishop', color: 'white'}, 
                    {type: 'knight', color: 'white'}, {type: 'rook', color: 'white'}
                ];
                
                return board;
            }
        }
        
        // ÙˆØ¸Ø§Ø¦Ù Ø§Ù„ØªÙ†Ù‚Ù„
        function showMainMenu() {
            document.querySelectorAll('.game-interface').forEach(el => el.classList.remove('active'));
            document.getElementById('main-menu').style.display = 'grid';
            currentGame = 'menu';
        }
        
        function showGame(gameType) {
            document.getElementById('main-menu').style.display = 'none';
            document.querySelectorAll('.game-interface').forEach(el => el.classList.remove('active'));
            
            const gameElement = document.getElementById(gameType + '-game');
            if (gameElement) {
                gameElement.classList.add('active');
                currentGame = gameType;
                initializeGame(gameType);
            }
        }
        
        function initializeGame(gameType) {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù„Ù„Ø¹Ø¨Ø©
            const difficulty = document.getElementById(gameType + '-difficulty')?.value || 'medium';
            gameAI = new GameAI(gameType, difficulty);
            
            switch(gameType) {
                case 'chess':
                    initializeChess();
                    break;
                case 'backgammon':
                    initializeBackgammon();
                    break;
                case 'domino':
                    initializeDomino();
                    break;
                case 'space':
                    initializeSpaceGame();
                    break;
                case 'racing':
                    initializeRacingGame();
                    break;
            }
        }
        
        // ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø´Ø·Ø±Ù†Ø¬
        function initializeChess() {
            const board = document.getElementById('chess-board');
            board.innerHTML = '';
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ù„ÙˆØ­Ø© Ø§Ù„Ø´Ø·Ø±Ù†Ø¬
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () => handleChessSquareClick(row, col);
                    
                    // ÙˆØ¶Ø¹ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
                    const piece = getInitialChessPiece(row, col);
                    if (piece) {
                        square.textContent = piece;
                    }
                    
                    board.appendChild(square);
                }
            }
            
            // ØªÙ‡ÙŠØ¦Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
            gameState.chess = {
                board: gameAI.getInitialChessBoard(),
                currentPlayer: 'white',
                selectedSquare: null,
                gameOver: false
            };
            
            updateChessStats();
        }
        
        function getInitialChessPiece(row, col) {
            const pieces = {
                0: ['â™œ', 'â™', 'â™', 'â™›', 'â™š', 'â™', 'â™', 'â™œ'],
                1: ['â™Ÿ', 'â™Ÿ', 'â™Ÿ', 'â™Ÿ', 'â™Ÿ', 'â™Ÿ', 'â™Ÿ', 'â™Ÿ'],
                6: ['â™™', 'â™™', 'â™™', 'â™™', 'â™™', 'â™™', 'â™™', 'â™™'],
                7: ['â™–', 'â™˜', 'â™—', 'â™•', 'â™”', 'â™—', 'â™˜', 'â™–']
            };
            
            return pieces[row] ? pieces[row][col] : '';
        }
        
        function handleChessSquareClick(row, col) {
            if (gameState.chess.gameOver || gameState.chess.currentPlayer !== 'white') return;
            
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            
            if (gameState.chess.selectedSquare) {
                // Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù‚Ø·Ø¹Ø©
                const fromRow = gameState.chess.selectedSquare.row;
                const fromCol = gameState.chess.selectedSquare.col;
                
                if (isValidChessMove(fromRow, fromCol, row, col)) {
                    makeChessMove(fromRow, fromCol, row, col);
                    gameState.chess.currentPlayer = 'black';
                    updateChessStats();
                    
                    // Ø¯ÙˆØ± Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±
                    setTimeout(makeAIChessMove, 1000);
                }
                
                // Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠØ¯
                document.querySelectorAll('.chess-square.selected').forEach(sq => sq.classList.remove('selected'));
                gameState.chess.selectedSquare = null;
            } else {
                // ØªØ­Ø¯ÙŠØ¯ Ù‚Ø·Ø¹Ø©
                const piece = gameState.chess.board[row][col];
                if (piece && piece.color === 'white') {
                    square.classList.add('selected');
                    gameState.chess.selectedSquare = {row, col};
                }
            }
        }
        
        function isValidChessMove(fromRow, fromCol, toRow, toCol) {
            // ÙØ­Øµ Ø¨Ø³ÙŠØ· Ù„Ù„Ø­Ø±ÙƒØ© Ø§Ù„ØµØ­ÙŠØ­Ø©
            const piece = gameState.chess.board[fromRow][fromCol];
            if (!piece) return false;
            
            const targetPiece = gameState.chess.board[toRow][toCol];
            if (targetPiece && targetPiece.color === piece.color) return false;
            
            // ÙØ­Øµ Ù…Ø¨Ø³Ø· Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ù‚Ø·Ø¹Ø©
            switch(piece.type) {
                case 'pawn':
                    return isValidPawnMove(fromRow, fromCol, toRow, toCol, piece.color);
                case 'rook':
                    return isValidRookMove(fromRow, fromCol, toRow, toCol);
                case 'knight':
                    return isValidKnightMove(fromRow, fromCol, toRow, toCol);
                // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù‚Ø·Ø¹
                default:
                    return true; // Ù…Ø¤Ù‚Øª
            }
        }
        
        function isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            
            // Ø­Ø±ÙƒØ© Ù„Ù„Ø£Ù…Ø§Ù…
            if (fromCol === toCol) {
                if (toRow === fromRow + direction && !gameState.chess.board[toRow][toCol]) {
                    return true;
                }
                if (fromRow === startRow && toRow === fromRow + 2 * direction && !gameState.chess.board[toRow][toCol]) {
                    return true;
                }
            }
            
            // Ø£ÙƒÙ„ Ù‚Ø·Ø±ÙŠ
            if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {
                return gameState.chess.board[toRow][toCol] && gameState.chess.board[toRow][toCol].color !== color;
            }
            
            return false;
        }
        
        function isValidRookMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            
            // ÙØ­Øµ Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ù‚Ø·Ø¹ ÙÙŠ Ø§Ù„Ø·Ø±ÙŠÙ‚
            const rowStep = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);
            const colStep = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);
            
            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (gameState.chess.board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }
            
            return true;
        }
        
        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(fromRow - toRow);
            const colDiff = Math.abs(fromCol - toCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }
        
        function makeChessMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.chess.board[fromRow][fromCol];
            gameState.chess.board[toRow][toCol] = piece;
            gameState.chess.board[fromRow][fromCol] = null;
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
            updateChessBoard();
        }
        
        function updateChessBoard() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    const piece = gameState.chess.board[row][col];
                    
                    if (piece) {
                        const pieceSymbols = {
                            'white': {
                                'king': 'â™”', 'queen': 'â™•', 'rook': 'â™–', 
                                'bishop': 'â™—', 'knight': 'â™˜', 'pawn': 'â™™'
                            },
                            'black': {
                                'king': 'â™š', 'queen': 'â™›', 'rook': 'â™œ', 
                                'bishop': 'â™', 'knight': 'â™', 'pawn': 'â™Ÿ'
                            }
                        };
                        square.textContent = pieceSymbols[piece.color][piece.type];
                    } else {
                        square.textContent = '';
                    }
                }
            }
        }
        
        async function makeAIChessMove() {
            if (gameState.chess.gameOver || gameState.chess.currentPlayer !== 'black') return;
            
            const move = await gameAI.makeMove(gameState.chess);
            if (move) {
                makeChessMove(move.from.row, move.from.col, move.to.row, move.to.col);
                gameState.chess.currentPlayer = 'white';
                updateChessStats();
            }
        }
        
        function updateChessStats() {
            document.getElementById('chess-turn').textContent = 
                gameState.chess.currentPlayer === 'white' ? 'Ø§Ù„Ø£Ø¨ÙŠØ¶' : 'Ø§Ù„Ø£Ø³ÙˆØ¯';
        }
        
        function newChessGame() {
            initializeChess();
        }
        
        function undoChessMove() {
            // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¨Ø³Ø· Ù„Ù„ØªØ±Ø§Ø¬Ø¹
            console.log('ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ø§Ù„Ø­Ø±ÙƒØ©');
        }
        
        function getChessHint() {
            if (gameState.chess.currentPlayer === 'white') {
                document.getElementById('chess-tips').textContent = 
                    'Ù†ØµÙŠØ­Ø©: Ø­Ø§ÙˆÙ„ ØªØ·ÙˆÙŠØ± Ù‚Ø·Ø¹Ùƒ Ù†Ø­Ùˆ Ø§Ù„Ù…Ø±ÙƒØ² ÙˆØ­Ù…Ø§ÙŠØ© Ø§Ù„Ù…Ù„Ùƒ.';
            }
        }
        
        function setChessDifficulty() {
            const difficulty = document.getElementById('chess-difficulty').value;
            if (gameAI) {
                gameAI.difficulty = difficulty;
                gameAI.thinkingTime = gameAI.getThinkingTime();
            }
            document.getElementById('chess-level').textContent = 
                {'easy': 'Ø³Ù‡Ù„', 'medium': 'Ù…ØªÙˆØ³Ø·', 'hard': 'ØµØ¹Ø¨', 'expert': 'Ø®Ø¨ÙŠØ±'}[difficulty];
        }
        
        // ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø·Ø§ÙˆÙ„Ø©
        function initializeBackgammon() {
            const board = document.getElementById('backgammon-board');
            board.innerHTML = '<p>Ù„ÙˆØ­Ø© Ø§Ù„Ø·Ø§ÙˆÙ„Ø© - Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯" Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨</p>';
            
            gameState.backgammon = {
                board: Array(24).fill().map(() => ({color: null, count: 0})),
                currentPlayer: 'white',
                dice: [],
                gameOver: false
            };
            
            updateBackgammonStats();
        }
        
        function rollBackgammonDice() {
            const dice1 = Math.floor(Math.random() * 6) + 1;
            const dice2 = Math.floor(Math.random() * 6) + 1;
            gameState.backgammon.dice = [dice1, dice2];
            
            document.getElementById('backgammon-dice').textContent = `${dice1}, ${dice2}`;
            
            // Ø¯ÙˆØ± Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¯ÙˆØ±Ù‡
            if (gameState.backgammon.currentPlayer === 'black') {
                setTimeout(makeAIBackgammonMove, 1500);
            }
        }
        
        async function makeAIBackgammonMove() {
            const move = await gameAI.makeMove(gameState.backgammon);
            if (move) {
                console.log('Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ù„Ø¹Ø¨:', move);
                gameState.backgammon.currentPlayer = 'white';
                updateBackgammonStats();
            }
        }
        
        function updateBackgammonStats() {
            document.getElementById('backgammon-turn').textContent = 
                gameState.backgammon.currentPlayer === 'white' ? 'Ø§Ù„Ù„Ø§Ø¹Ø¨' : 'Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±';
        }
        
        function newBackgammonGame() {
            initializeBackgammon();
        }
        
        function getBackgammonHint() {
            document.getElementById('backgammon-tips').textContent = 
                'Ù†ØµÙŠØ­Ø©: Ø­Ø§ÙˆÙ„ Ø¨Ù†Ø§Ø¡ Ù†Ù‚Ø§Ø· Ù‚ÙˆÙŠØ© Ù„Ù…Ù†Ø¹ Ø®ØµÙ…Ùƒ Ù…Ù† Ø§Ù„ØªÙ‚Ø¯Ù….';
        }
        
        function changeBackgammonType() {
            const type = document.getElementById('backgammon-type').value;
            console.log('ØªØºÙŠÙŠØ± Ù†ÙˆØ¹ Ø§Ù„Ø·Ø§ÙˆÙ„Ø© Ø¥Ù„Ù‰:', type);
            newBackgammonGame();
        }
        
        // ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ
        function initializeDomino() {
            const board = document.getElementById('domino-board');
            board.innerHTML = '<p>Ù„ÙˆØ­Ø© Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ - Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©" Ù„Ù„Ø¨Ø¯Ø¡</p>';
            
            gameState.domino = {
                board: [],
                playerHand: [],
                aiHand: [],
                currentPlayer: 'player',
                gameOver: false
            };
            
            updateDominoStats();
        }
        
        function newDominoGame() {
            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ (28 Ù‚Ø·Ø¹Ø©)
            const dominoSet = [];
            for (let i = 0; i <= 6; i++) {
                for (let j = i; j <= 6; j++) {
                    dominoSet.push([i, j]);
                }
            }
            
            // Ø®Ù„Ø· Ø§Ù„Ù‚Ø·Ø¹
            for (let i = dominoSet.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [dominoSet[i], dominoSet[j]] = [dominoSet[j], dominoSet[i]];
            }
            
            // ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù‚Ø·Ø¹
            gameState.domino.playerHand = dominoSet.slice(0, 7);
            gameState.domino.aiHand = dominoSet.slice(7, 14);
            gameState.domino.board = [];
            gameState.domino.currentPlayer = 'player';
            gameState.domino.gameOver = false;
            
            // Ø¹Ø±Ø¶ ÙŠØ¯ Ø§Ù„Ù„Ø§Ø¹Ø¨
            displayPlayerDominoHand();
            updateDominoStats();
        }
        
        function displayPlayerDominoHand() {
            const board = document.getElementById('domino-board');
            let html = '<div style="margin-bottom: 20px;"><h3>Ù‚Ø·Ø¹Ùƒ:</h3><div style="display: flex; gap: 10px; flex-wrap: wrap;">';
            
            gameState.domino.playerHand.forEach((piece, index) => {
                html += `<div onclick="playDominoPiece(${index})" style="background: white; color: black; padding: 10px; border-radius: 5px; cursor: pointer; border: 2px solid #333;">
                    ${piece[0]} | ${piece[1]}
                </div>`;
            });
            
            html += '</div></div>';
            
            if (gameState.domino.board.length > 0) {
                html += '<div><h3>Ø§Ù„Ù„ÙˆØ­Ø©:</h3><div style="display: flex; gap: 5px; flex-wrap: wrap;">';
                gameState.domino.board.forEach(piece => {
                    html += `<div style="background: #444; padding: 8px; border-radius: 3px;">${piece[0]} | ${piece[1]}</div>`;
                });
                html += '</div></div>';
            }
            
            board.innerHTML = html;
        }
        
        function playDominoPiece(index) {
            if (gameState.domino.currentPlayer !== 'player') return;
            
            const piece = gameState.domino.playerHand[index];
            
            if (gameState.domino.board.length === 0) {
                // Ø£ÙˆÙ„ Ù‚Ø·Ø¹Ø©
                gameState.domino.board.push(piece);
                gameState.domino.playerHand.splice(index, 1);
            } else {
                // ÙØ­Øµ Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨
                const leftEnd = gameState.domino.board[0][0];
                const rightEnd = gameState.domino.board[gameState.domino.board.length - 1][1];
                
                if (piece[0] === leftEnd || piece[1] === leftEnd) {
                    // Ù„Ø¹Ø¨ Ø¹Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø±
                    if (piece[1] === leftEnd) {
                        gameState.domino.board.unshift([piece[0], piece[1]]);
                    } else {
                        gameState.domino.board.unshift([piece[1], piece[0]]);
                    }
                    gameState.domino.playerHand.splice(index, 1);
                } else if (piece[0] === rightEnd || piece[1] === rightEnd) {
                    // Ù„Ø¹Ø¨ Ø¹Ù„Ù‰ Ø§Ù„ÙŠÙ…ÙŠÙ†
                    if (piece[0] === rightEnd) {
                        gameState.domino.board.push([piece[0], piece[1]]);
                    } else {
                        gameState.domino.board.push([piece[1], piece[0]]);
                    }
                    gameState.domino.playerHand.splice(index, 1);
                } else {
                    alert('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù„Ø¹Ø¨ Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø·Ø¹Ø©!');
                    return;
                }
            }
            
            gameState.domino.currentPlayer = 'ai';
            displayPlayerDominoHand();
            updateDominoStats();
            
            // ÙØ­Øµ Ø§Ù„ÙÙˆØ²
            if (gameState.domino.playerHand.length === 0) {
                alert('Ù…Ø¨Ø±ÙˆÙƒ! Ù„Ù‚Ø¯ ÙØ²Øª!');
                gameState.domino.gameOver = true;
                return;
            }
            
            // Ø¯ÙˆØ± Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±
            setTimeout(makeAIDominoMove, 1500);
        }
        
        async function makeAIDominoMove() {
            const move = await gameAI.makeMove(gameState.domino);
            if (move) {
                const piece = move.piece;
                
                if (move.position === 'start') {
                    gameState.domino.board.push(piece);
                } else if (move.position === 'left') {
                    const leftEnd = gameState.domino.board[0][0];
                    if (piece[1] === leftEnd) {
                        gameState.domino.board.unshift([piece[0], piece[1]]);
                    } else {
                        gameState.domino.board.unshift([piece[1], piece[0]]);
                    }
                } else if (move.position === 'right') {
                    const rightEnd = gameState.domino.board[gameState.domino.board.length - 1][1];
                    if (piece[0] === rightEnd) {
                        gameState.domino.board.push([piece[0], piece[1]]);
                    } else {
                        gameState.domino.board.push([piece[1], piece[0]]);
                    }
                }
                
                gameState.domino.aiHand.splice(move.index, 1);
                gameState.domino.currentPlayer = 'player';
                
                displayPlayerDominoHand();
                updateDominoStats();
                
                // ÙØ­Øµ ÙÙˆØ² Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±
                if (gameState.domino.aiHand.length === 0) {
                    alert('Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± ÙØ§Ø²! Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.');
                    gameState.domino.gameOver = true;
                }
            } else {
                // Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ù„Ø§ ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„Ù„Ø¹Ø¨
                gameState.domino.currentPlayer = 'player';
                updateDominoStats();
            }
        }
        
        function updateDominoStats() {
            document.getElementById('domino-player-pieces').textContent = gameState.domino.playerHand?.length || 0;
            document.getElementById('domino-turn').textContent = 
                gameState.domino.currentPlayer === 'player' ? 'Ø§Ù„Ù„Ø§Ø¹Ø¨' : 'Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±';
        }
        
        function passDominoTurn() {
            if (gameState.domino.currentPlayer === 'player') {
                gameState.domino.currentPlayer = 'ai';
                updateDominoStats();
                setTimeout(makeAIDominoMove, 1000);
            }
        }
        
        function getDominoHint() {
            document.getElementById('domino-tips').textContent = 
                'Ù†ØµÙŠØ­Ø©: Ø­Ø§ÙˆÙ„ Ø§Ù„ØªØ®Ù„Øµ Ù…Ù† Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø«Ù‚ÙŠÙ„Ø© Ø£ÙˆÙ„Ø§Ù‹ ÙˆØ±Ø§Ù‚Ø¨ Ù‚Ø·Ø¹ Ø§Ù„Ø®ØµÙ….';
        }
        
        // ÙˆØ¸Ø§Ø¦Ù Ø­Ø±Ø¨ Ø§Ù„Ù†Ø¬ÙˆÙ…
        let spaceGameEngine = null;
        
        function initializeSpaceGame() {
            const canvas = document.getElementById('space-canvas');
            const ctx = canvas.getContext('2d');
            
            spaceGameEngine = new SpaceGameEngine(canvas, ctx);
            updateSpaceStats();
        }
        
        class SpaceGameEngine {
            constructor(canvas, ctx) {
                this.canvas = canvas;
                this.ctx = ctx;
                this.player = {x: canvas.width / 2, y: canvas.height - 50, width: 40, height: 40};
                this.enemies = [];
                this.bullets = [];
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.gameRunning = false;
                this.difficulty = 'medium';
                
                this.bindEvents();
            }
            
            bindEvents() {
                document.addEventListener('keydown', (e) => {
                    if (!this.gameRunning) return;
                    
                    switch(e.key) {
                        case 'ArrowLeft':
                            this.player.x = Math.max(0, this.player.x - 20);
                            break;
                        case 'ArrowRight':
                            this.player.x = Math.min(this.canvas.width - this.player.width, this.player.x + 20);
                            break;
                        case ' ':
                            this.shoot();
                            e.preventDefault();
                            break;
                    }
                });
            }
            
            start() {
                this.gameRunning = true;
                this.gameLoop();
                this.spawnEnemies();
            }
            
            pause() {
                this.gameRunning = false;
            }
            
            reset() {
                this.player.x = this.canvas.width / 2;
                this.enemies = [];
                this.bullets = [];
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.gameRunning = false;
                this.draw();
                updateSpaceStats();
            }
            
            shoot() {
                this.bullets.push({
                    x: this.player.x + this.player.width / 2,
                    y: this.player.y,
                    width: 4,
                    height: 10
                });
            }
            
            spawnEnemies() {
                if (!this.gameRunning) return;
                
                const spawnRate = this.difficulty === 'easy' ? 2000 : 
                                 this.difficulty === 'medium' ? 1500 : 
                                 this.difficulty === 'hard' ? 1000 : 800;
                
                if (Math.random() < 0.7) {
                    this.enemies.push({
                        x: Math.random() * (this.canvas.width - 30),
                        y: -30,
                        width: 30,
                        height: 30,
                        speed: 2 + this.level * 0.5
                    });
                }
                
                setTimeout(() => this.spawnEnemies(), spawnRate);
            }
            
            gameLoop() {
                if (!this.gameRunning) return;
                
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±ØµØ§ØµØ§Øª
                this.bullets = this.bullets.filter(bullet => {
                    bullet.y -= 8;
                    return bullet.y > -bullet.height;
                });
                
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡
                this.enemies = this.enemies.filter(enemy => {
                    enemy.y += enemy.speed;
                    
                    // ÙØ­Øµ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ù…Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨
                    if (this.checkCollision(enemy, this.player)) {
                        this.lives--;
                        updateSpaceStats();
                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                        return false;
                    }
                    
                    return enemy.y < this.canvas.height;
                });
                
                // ÙØ­Øµ Ø¥ØµØ§Ø¨Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        if (this.checkCollision(this.bullets[i], this.enemies[j])) {
                            this.bullets.splice(i, 1);
                            this.enemies.splice(j, 1);
                            this.score += 10;
                            updateSpaceStats();
                            break;
                        }
                    }
                }
            }
            
            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
            
            draw() {
                // Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Ø´Ø©
                this.ctx.fillStyle = '#000428';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Ø±Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                
                // Ø±Ø³Ù… Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡
                this.ctx.fillStyle = '#ff0000';
                this.enemies.forEach(enemy => {
                    this.ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                });
                
                // Ø±Ø³Ù… Ø§Ù„Ø±ØµØ§ØµØ§Øª
                this.ctx.fillStyle = '#ffff00';
                this.bullets.forEach(bullet => {
                    this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });
            }
            
            gameOver() {
                this.gameRunning = false;
                alert(`Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©! Ø§Ù„Ù†Ù‚Ø§Ø·: ${this.score}`);
            }
            
            setDifficulty(difficulty) {
                this.difficulty = difficulty;
            }
        }
        
        function startSpaceGame() {
            if (spaceGameEngine) {
                spaceGameEngine.start();
            }
        }
        
        function pauseSpaceGame() {
            if (spaceGameEngine) {
                spaceGameEngine.pause();
            }
        }
        
        function newSpaceGame() {
            if (spaceGameEngine) {
                spaceGameEngine.reset();
            }
        }
        
        function setSpaceDifficulty() {
            const difficulty = document.getElementById('space-difficulty').value;
            if (spaceGameEngine) {
                spaceGameEngine.setDifficulty(difficulty);
            }
        }
        
        function updateSpaceStats() {
            if (spaceGameEngine) {
                document.getElementById('space-score').textContent = spaceGameEngine.score;
                document.getElementById('space-lives').textContent = spaceGameEngine.lives;
                document.getElementById('space-level').textContent = spaceGameEngine.level;
                document.getElementById('space-enemies').textContent = spaceGameEngine.enemies.length;
            }
        }
        
        // ÙˆØ¸Ø§Ø¦Ù Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ø±Ø§Øª
        let racingGameEngine = null;
        
        function initializeRacingGame() {
            const canvas = document.getElementById('racing-canvas');
            const ctx = canvas.getContext('2d');
            
            racingGameEngine = new RacingGameEngine(canvas, ctx);
            updateRacingStats();
        }
        
        class RacingGameEngine {
            constructor(canvas, ctx) {
                this.canvas = canvas;
                this.ctx = ctx;
                this.player = {x: canvas.width / 2, y: canvas.height - 80, width: 40, height: 60};
                this.obstacles = [];
                this.score = 0;
                this.speed = 0;
                this.distance = 0;
                this.time = 0;
                this.gameRunning = false;
                this.difficulty = 'medium';
                
                this.bindEvents();
            }
            
            bindEvents() {
                document.addEventListener('keydown', (e) => {
                    if (!this.gameRunning) return;
                    
                    switch(e.key) {
                        case 'ArrowLeft':
                            this.player.x = Math.max(50, this.player.x - 25);
                            break;
                        case 'ArrowRight':
                            this.player.x = Math.min(this.canvas.width - 90, this.player.x + 25);
                            break;
                    }
                });
            }
            
            start() {
                this.gameRunning = true;
                this.startTime = Date.now();
                this.gameLoop();
                this.spawnObstacles();
            }
            
            pause() {
                this.gameRunning = false;
            }
            
            reset() {
                this.player.x = this.canvas.width / 2;
                this.obstacles = [];
                this.score = 0;
                this.speed = 0;
                this.distance = 0;
                this.time = 0;
                this.gameRunning = false;
                this.draw();
                updateRacingStats();
            }
            
            spawnObstacles() {
                if (!this.gameRunning) return;
                
                const spawnRate = this.difficulty === 'easy' ? 2500 : 
                                 this.difficulty === 'medium' ? 2000 : 
                                 this.difficulty === 'hard' ? 1500 : 1000;
                
                if (Math.random() < 0.8) {
                    const lanes = [100, 200, 300];
                    const lane = lanes[Math.floor(Math.random() * lanes.length)];
                    
                    this.obstacles.push({
                        x: lane,
                        y: -60,
                        width: 40,
                        height: 60,
                        speed: 4 + Math.random() * 3
                    });
                }
                
                setTimeout(() => this.spawnObstacles(), spawnRate);
            }
            
            gameLoop() {
                if (!this.gameRunning) return;
                
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª ÙˆØ§Ù„Ù…Ø³Ø§ÙØ©
                this.time = Math.floor((Date.now() - this.startTime) / 1000);
                this.distance += 1;
                this.speed = Math.floor(this.distance / 10);
                this.score = this.distance;
                
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹ÙˆØ§Ø¦Ù‚
                this.obstacles = this.obstacles.filter(obstacle => {
                    obstacle.y += obstacle.speed;
                    
                    // ÙØ­Øµ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
                    if (this.checkCollision(obstacle, this.player)) {
                        this.gameOver();
                        return false;
                    }
                    
                    return obstacle.y < this.canvas.height;
                });
                
                updateRacingStats();
            }
            
            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
            
            draw() {
                // Ø±Ø³Ù… Ø§Ù„Ø·Ø±ÙŠÙ‚
                this.ctx.fillStyle = '#666';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ·
                this.ctx.fillStyle = '#fff';
                for (let i = 0; i < this.canvas.height; i += 40) {
                    this.ctx.fillRect(this.canvas.width / 2 - 2, i, 4, 20);
                }
                
                // Ø±Ø³Ù… Ø§Ù„Ø­ÙˆØ§Ù
                this.ctx.fillStyle = '#228B22';
                this.ctx.fillRect(0, 0, 50, this.canvas.height);
                this.ctx.fillRect(this.canvas.width - 50, 0, 50, this.canvas.height);
                
                // Ø±Ø³Ù… Ø§Ù„Ø³ÙŠØ§Ø±Ø©
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                
                // Ø±Ø³Ù… Ø§Ù„Ø¹ÙˆØ§Ø¦Ù‚
                this.ctx.fillStyle = '#0000ff';
                this.obstacles.forEach(obstacle => {
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                });
            }
            
            gameOver() {
                this.gameRunning = false;
                alert(`Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø³Ø¨Ø§Ù‚! Ø§Ù„Ù…Ø³Ø§ÙØ©: ${this.distance} Ù…ØªØ±ØŒ Ø§Ù„ÙˆÙ‚Øª: ${this.time} Ø«Ø§Ù†ÙŠØ©`);
            }
            
            setDifficulty(difficulty) {
                this.difficulty = difficulty;
            }
        }
        
        function startRacingGame() {
            if (racingGameEngine) {
                racingGameEngine.start();
            }
        }
        
        function pauseRacingGame() {
            if (racingGameEngine) {
                racingGameEngine.pause();
            }
        }
        
        function newRacingGame() {
            if (racingGameEngine) {
                racingGameEngine.reset();
            }
        }
        
        function setRacingDifficulty() {
            const difficulty = document.getElementById('racing-difficulty').value;
            if (racingGameEngine) {
                racingGameEngine.setDifficulty(difficulty);
            }
        }
        
        function updateRacingStats() {
            if (racingGameEngine) {
                document.getElementById('racing-time').textContent = racingGameEngine.time;
                document.getElementById('racing-distance').textContent = racingGameEngine.distance;
                document.getElementById('racing-speed').textContent = racingGameEngine.speed;
                document.getElementById('racing-score').textContent = racingGameEngine.score;
            }
        }
        
        // ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©
        function showTutorial(gameType) {
            const tutorials = {
                'chess': 'Ø¯Ø±ÙˆØ³ Ø§Ù„Ø´Ø·Ø±Ù†Ø¬: ØªØ¹Ù„Ù… Ø­Ø±ÙƒØ© ÙƒÙ„ Ù‚Ø·Ø¹Ø©ØŒ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø§ÙØªØªØ§Ø­ØŒ ÙˆØ§Ù„ØªÙƒØªÙŠÙƒØ§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©.',
                'backgammon': 'Ø¯Ø±ÙˆØ³ Ø§Ù„Ø·Ø§ÙˆÙ„Ø©: ØªØ¹Ù„Ù… Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ù„Ø¹Ø¨Ø©ØŒ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø­Ø±ÙƒØ©ØŒ ÙˆØ·Ø±Ù‚ Ø§Ù„ÙÙˆØ².',
                'domino': 'Ø¯Ø±ÙˆØ³ Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ: ØªØ¹Ù„Ù… ÙƒÙŠÙÙŠØ© Ø§Ù„Ù„Ø¹Ø¨ØŒ Ø§Ù„ØªØ®Ø·ÙŠØ· Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØŒ ÙˆØ­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø·.',
                'space': 'Ø¯Ø±ÙˆØ³ Ø­Ø±Ø¨ Ø§Ù„Ù†Ø¬ÙˆÙ…: ØªØ¹Ù„Ù… Ø§Ù„ØªØ­ÙƒÙ…ØŒ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¨Ù‚Ø§Ø¡ØŒ ÙˆØªØ­Ø³ÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø·.',
                'racing': 'Ø¯Ø±ÙˆØ³ Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ø±Ø§Øª: ØªØ¹Ù„Ù… Ø§Ù„ØªØ­ÙƒÙ…ØŒ ØªØ¬Ù†Ø¨ Ø§Ù„Ø¹ÙˆØ§Ø¦Ù‚ØŒ ÙˆØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡.'
            };
            
            alert(tutorials[gameType] || 'Ø§Ù„Ø¯Ø±ÙˆØ³ Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±');
        }
        
        // Ø¯Ø¹Ù… Ø§Ù„ØªØ­ÙƒÙ… Ø¹Ù† Ø¨Ø¹Ø¯
        document.addEventListener('keydown', function(e) {
            // Ø¯Ø¹Ù… Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙ„ÙØ²ÙŠÙˆÙ† Ø§Ù„Ø°ÙƒÙŠ
            switch(e.key) {
                case 'Enter':
                    // Ø²Ø± OK
                    if (currentGame === 'menu') {
                        const firstButton = document.querySelector('.play-button');
                        if (firstButton) firstButton.click();
                    }
                    break;
                case 'Escape':
                    // Ø²Ø± Back
                    if (currentGame !== 'menu') {
                        showMainMenu();
                    }
                    break;
                case 'Home':
                    // Ø²Ø± Home
                    showMainMenu();
                    break;
            }
        });
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…ÙˆÙ‚Ø¹
        document.addEventListener('DOMContentLoaded', function() {
            showMainMenu();
        });
    </script>
</body>
</html>
